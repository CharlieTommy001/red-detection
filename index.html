<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const message = document.getElementById('message');
    const startBtn = document.getElementById('startBtn');
    const alarmAudio = document.getElementById('alarmAudio');

    startBtn.addEventListener('click', initCameraAndDetection);

    function initCameraAndDetection() {
        startBtn.style.display = 'none';

        const constraints = {
            audio: false,
            video: {
                facingMode: 'environment'
            }
        };

        navigator.mediaDevices.getUserMedia(constraints)
            .then(stream => {
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    startDetectionLoop();
                };
            })
            .catch(err => {
                console.error('无法访问摄像头：', err);
                alert('无法访问摄像头，请检查权限或使用支持的设备与浏览器。');
            });
    }

    let previousYPositions = [];
    const maxHistory = 10; // 保存最近 10 帧的 Y 坐标数据
    const shakeThreshold = 5; // 定义 Y 坐标抖动的变化幅度阈值

    function startDetectionLoop() {
        setInterval(() => {
            detectRedObjectMovement();
        }, 100);
    }

    function detectRedObjectMovement() {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const frameData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const result = detectRedObjectCenter(frameData.data, canvas.width, canvas.height);

        if (result.count > 0) {
            if (previousYPositions.length >= maxHistory) {
                previousYPositions.shift(); // 移除最早的数据点
            }
            previousYPositions.push(result.y);

            if (isShaking(previousYPositions)) {
                showAlarm();
            }
        }
    }

    function detectRedObjectCenter(data, width, height) {
        const regionWidth = Math.floor(width / 3);
        const regionHeight = Math.floor(height / 5);
        const xStart = Math.floor((width - regionWidth) / 2);
        const yStart = Math.floor((height - regionHeight) / 2);
        const xEnd = xStart + regionWidth;
        const yEnd = yStart + regionHeight;

        let redCount = 0;
        let sumX = 0;
        let sumY = 0;

        for (let y = yStart; y < yEnd; y++) {
            for (let x = xStart; x < xEnd; x++) {
                const idx = (y * width + x) * 4;
                const r = data[idx];
                const g = data[idx + 1];
                const b = data[idx + 2];

                if (r > 150 && g < 80 && b < 80) {
                    redCount++;
                    sumX += x;
                    sumY += y;
                }
            }
        }

        if (redCount > 0) {
            return {
                count: redCount,
                x: sumX / redCount,
                y: sumY / redCount
            };
        } else {
            return {
                count: 0,
                x: 0,
                y: 0
            };
        }
    }

    function isShaking(yPositions) {
        if (yPositions.length < 2) return false;

        // 计算 Y 坐标的变化量
        const diffs = [];
        for (let i = 1; i < yPositions.length; i++) {
            diffs.push(Math.abs(yPositions[i] - yPositions[i - 1]));
        }

        // 计算变化量的平均值和判断是否抖动
        const avgDiff = diffs.reduce((a, b) => a + b, 0) / diffs.length;
        return avgDiff > shakeThreshold;
    }

    function showAlarm() {
        message.style.display = 'block';
        try {
            alarmAudio.currentTime = 0;
            alarmAudio.play().catch(err => {
                console.warn('音频播放被阻止或发生错误：', err);
            });
        } catch (e) {
            console.warn('播放报警音异常：', e);
        }

        setTimeout(() => {
            message.style.display = 'none';
        }, 3000);
    }
</script>

